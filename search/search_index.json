{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to PyPDFForm PyPDFForm is a free and open source pure-Python 3 library for PDF form processing. It contains the essential functionalities needed to interact with PDF forms: Inspect what data a PDF form needs to be filled with. Fill a PDF form by simply creating a Python dictionary. Create a subset of form widgets on a PDF. It also supports other common utilities such as extracting pages and merging multiple PDFs together. User Guide Installation and setup PDF coordinates Prepare a PDF form Inspect a PDF form Fill a PDF form Fill a PDF form in place Change text field styles Change checkbox and radio button styles Draw stuffs Other utilities Developer Guide Developer Intro Pull Request Requirements Hosting Docs Locally Testing Releasing","title":"Welcome to PyPDFForm"},{"location":"#welcome-to-pypdfform","text":"PyPDFForm is a free and open source pure-Python 3 library for PDF form processing. It contains the essential functionalities needed to interact with PDF forms: Inspect what data a PDF form needs to be filled with. Fill a PDF form by simply creating a Python dictionary. Create a subset of form widgets on a PDF. It also supports other common utilities such as extracting pages and merging multiple PDFs together.","title":"Welcome to PyPDFForm"},{"location":"#user-guide","text":"Installation and setup PDF coordinates Prepare a PDF form Inspect a PDF form Fill a PDF form Fill a PDF form in place Change text field styles Change checkbox and radio button styles Draw stuffs Other utilities","title":"User Guide"},{"location":"#developer-guide","text":"Developer Intro Pull Request Requirements Hosting Docs Locally Testing Releasing","title":"Developer Guide"},{"location":"button_style/","text":"Change checkbox and radio button styles Similar to text fields discussed in the last chapter, PyPDFForm gives you the ability to modify some styles of checkboxes and radio buttons without changing the template. Change size You can change the size of the selection by specifying a float value. Consider this PDF : from PyPDFForm import PdfWrapper form = PdfWrapper(\"sample_template.pdf\") form.widgets[\"check\"].size = 50 form.widgets[\"check_2\"].size = 40 form.widgets[\"check_3\"].size = 60 form.fill( { \"check\": True, \"check_2\": True, \"check_3\": True, }, ) with open(\"output.pdf\", \"wb+\") as output: output.write(form.read()) Change button style The button style is the shape of the selection on a checkbox or radio button. PyPDFForm lets you pick three different button styles: check , circle , and cross . Consider this PDF : from PyPDFForm import PdfWrapper form = PdfWrapper(\"sample_template_with_radio_button.pdf\") form.widgets[\"radio_1\"].button_style = \"cross\" form.widgets[\"radio_2\"].button_style = \"circle\" form.widgets[\"radio_3\"].button_style = \"check\" form.fill( { \"radio_1\": 0, \"radio_2\": 1, \"radio_3\": 2, }, ) with open(\"output.pdf\", \"wb+\") as output: output.write(form.read())","title":"Change checkbox and radio button styles"},{"location":"button_style/#change-checkbox-and-radio-button-styles","text":"Similar to text fields discussed in the last chapter, PyPDFForm gives you the ability to modify some styles of checkboxes and radio buttons without changing the template.","title":"Change checkbox and radio button styles"},{"location":"button_style/#change-size","text":"You can change the size of the selection by specifying a float value. Consider this PDF : from PyPDFForm import PdfWrapper form = PdfWrapper(\"sample_template.pdf\") form.widgets[\"check\"].size = 50 form.widgets[\"check_2\"].size = 40 form.widgets[\"check_3\"].size = 60 form.fill( { \"check\": True, \"check_2\": True, \"check_3\": True, }, ) with open(\"output.pdf\", \"wb+\") as output: output.write(form.read())","title":"Change size"},{"location":"button_style/#change-button-style","text":"The button style is the shape of the selection on a checkbox or radio button. PyPDFForm lets you pick three different button styles: check , circle , and cross . Consider this PDF : from PyPDFForm import PdfWrapper form = PdfWrapper(\"sample_template_with_radio_button.pdf\") form.widgets[\"radio_1\"].button_style = \"cross\" form.widgets[\"radio_2\"].button_style = \"circle\" form.widgets[\"radio_3\"].button_style = \"check\" form.fill( { \"radio_1\": 0, \"radio_2\": 1, \"radio_3\": 2, }, ) with open(\"output.pdf\", \"wb+\") as output: output.write(form.read())","title":"Change button style"},{"location":"coordinate/","text":"PDF coordinates The coordinate system on a single page of a PDF starts at the bottom left of the page as the origin. The unit of the coordinates is called \"points\" and there are 72 points/inch. PyPDFForm utilizes this coordinate system in some of its APIs so that widgets, texts, or images can be created on a PDF. Generate a coordinate grid view To allow a better user experience with the coordinate system, PyPDFForm implements a grid view so that there is a better idea on where stuffs should be placed on a PDF. Consider this PDF , the coordinate grid view can be generated like this: from PyPDFForm import PdfWrapper grid_view_pdf = PdfWrapper( \"sample_template.pdf\" ).generate_coordinate_grid( color=(1, 0, 0), # optional margin=100 # optional ) with open(\"output.pdf\", \"wb+\") as output: output.write(grid_view_pdf.read()) The generate_coordinate_grid method takes two optional parameters. The first one is color which allows you to pick a color for the grid view. The default color is red. The second one is margin which allows you to change the coordinate grid view's margin in points. The default margin is 100 points.","title":"PDF coordinates"},{"location":"coordinate/#pdf-coordinates","text":"The coordinate system on a single page of a PDF starts at the bottom left of the page as the origin. The unit of the coordinates is called \"points\" and there are 72 points/inch. PyPDFForm utilizes this coordinate system in some of its APIs so that widgets, texts, or images can be created on a PDF.","title":"PDF coordinates"},{"location":"coordinate/#generate-a-coordinate-grid-view","text":"To allow a better user experience with the coordinate system, PyPDFForm implements a grid view so that there is a better idea on where stuffs should be placed on a PDF. Consider this PDF , the coordinate grid view can be generated like this: from PyPDFForm import PdfWrapper grid_view_pdf = PdfWrapper( \"sample_template.pdf\" ).generate_coordinate_grid( color=(1, 0, 0), # optional margin=100 # optional ) with open(\"output.pdf\", \"wb+\") as output: output.write(grid_view_pdf.read()) The generate_coordinate_grid method takes two optional parameters. The first one is color which allows you to pick a color for the grid view. The default color is red. The second one is margin which allows you to change the coordinate grid view's margin in points. The default margin is 100 points.","title":"Generate a coordinate grid view"},{"location":"dev_changes/","text":"Pull Request Requirements Whenever a pull request is submitted, there are some expectations for the content before it can be merged into the master branch. Code changes There isn't any strict rule on how coding should be done for PyPDFForm. The project welcomes code contributions from anyone with any level of expertise. With that said, there are some conventions that are expected to be followed by your PR: Your changes must pass Pylint . To check if this is true, simply run pylint PyPDFForm . Your changes must pass all tests and have 100% coverage. You can read more about testing here . If you are changing the user APIs or any other parts of the code that are relevant, please update the appropriate documentation too. Merge process Your PR will be reviewed before merging into the master branch. On top of that, it needs to run through some CI checks: Pylint on the source code. Tests will be run on three mainstream operating systems: ubuntu , windows , and macos , and across all Python versions the library supports on each OS. Once the CI is green and your code looks good, the PR will be merged into the master branch. After every PR merge, black and isort will be run on your code, and they will be deployed on the next release.","title":"Pull Request Requirements"},{"location":"dev_changes/#pull-request-requirements","text":"Whenever a pull request is submitted, there are some expectations for the content before it can be merged into the master branch.","title":"Pull Request Requirements"},{"location":"dev_changes/#code-changes","text":"There isn't any strict rule on how coding should be done for PyPDFForm. The project welcomes code contributions from anyone with any level of expertise. With that said, there are some conventions that are expected to be followed by your PR: Your changes must pass Pylint . To check if this is true, simply run pylint PyPDFForm . Your changes must pass all tests and have 100% coverage. You can read more about testing here . If you are changing the user APIs or any other parts of the code that are relevant, please update the appropriate documentation too.","title":"Code changes"},{"location":"dev_changes/#merge-process","text":"Your PR will be reviewed before merging into the master branch. On top of that, it needs to run through some CI checks: Pylint on the source code. Tests will be run on three mainstream operating systems: ubuntu , windows , and macos , and across all Python versions the library supports on each OS. Once the CI is green and your code looks good, the PR will be merged into the master branch. After every PR merge, black and isort will be run on your code, and they will be deployed on the next release.","title":"Merge process"},{"location":"dev_doc/","text":"Hosting Docs Locally When the changes apply to the user APIs or any other parts of the code that are relevant, the appropriate documentation should also be updated. PyPDFForm uses MkDocs for building the documentation. To host the doc site locally, simply run: mkdocs serve And you will find the doc site at http://127.0.0.1:8000/ .","title":"Hosting Docs Locally"},{"location":"dev_doc/#hosting-docs-locally","text":"When the changes apply to the user APIs or any other parts of the code that are relevant, the appropriate documentation should also be updated. PyPDFForm uses MkDocs for building the documentation. To host the doc site locally, simply run: mkdocs serve And you will find the doc site at http://127.0.0.1:8000/ .","title":"Hosting Docs Locally"},{"location":"dev_intro/","text":"Developer Intro PyPDFForm's targeted users are other Python developers. This section of the documentation is not for the users, but for people who want to start making contributions to PyPDFForm itself. Installing requirements It is advised that a virtual environment is created before running this command: pip install -r requirements.txt Running tests See testing PyPDFForm with pytest . Creating issues When you create an issue on GitHub, try your best to follow these conventions: The issue title should have the format PPF-<issue number>: <title of the issue> . The issue description should be as descriptive as possible, preferably with the following: A code snippet related to the issue. A PDF form template used by the code snippet. Screenshots that can help visualize the issue. Opening pull requests Please create an issue before making a pull request. Try your best to follow these conventions when doing so: The PR title should be the same as its respective issue, so PPF-<issue number>: <title of the issue> . The PR description should contain a brief explanation of the changes. Once opened, the PR should be linked to its respective issue.","title":"Developer Intro"},{"location":"dev_intro/#developer-intro","text":"PyPDFForm's targeted users are other Python developers. This section of the documentation is not for the users, but for people who want to start making contributions to PyPDFForm itself.","title":"Developer Intro"},{"location":"dev_intro/#installing-requirements","text":"It is advised that a virtual environment is created before running this command: pip install -r requirements.txt","title":"Installing requirements"},{"location":"dev_intro/#running-tests","text":"See testing PyPDFForm with pytest .","title":"Running tests"},{"location":"dev_intro/#creating-issues","text":"When you create an issue on GitHub, try your best to follow these conventions: The issue title should have the format PPF-<issue number>: <title of the issue> . The issue description should be as descriptive as possible, preferably with the following: A code snippet related to the issue. A PDF form template used by the code snippet. Screenshots that can help visualize the issue.","title":"Creating issues"},{"location":"dev_intro/#opening-pull-requests","text":"Please create an issue before making a pull request. Try your best to follow these conventions when doing so: The PR title should be the same as its respective issue, so PPF-<issue number>: <title of the issue> . The PR description should contain a brief explanation of the changes. Once opened, the PR should be linked to its respective issue.","title":"Opening pull requests"},{"location":"dev_release/","text":"Releasing A PyPDFForm release starts with the following steps: A release issue and PR . A new GitHub release with auto-generated changelogs. Once these steps are done, the CI for deployment will be triggered. Deploy process When the GitHub release is created, it will trigger two different CIs: Deploy , which will create the distribution and upload it to PyPI . Deploy Docs , which will tear down and rebuild the GitHub page where the doc site is hosted. When are releases done? It depends on the changes that are currently on the master branch but have not deployed yet. Generally speaking: Serious bugs are usually released immediately after they are fixed. New features can usually wait and are released on a weekly basis. Trivial changes are usually bundled with other changes and can wait indefinitely.","title":"Releasing"},{"location":"dev_release/#releasing","text":"A PyPDFForm release starts with the following steps: A release issue and PR . A new GitHub release with auto-generated changelogs. Once these steps are done, the CI for deployment will be triggered.","title":"Releasing"},{"location":"dev_release/#deploy-process","text":"When the GitHub release is created, it will trigger two different CIs: Deploy , which will create the distribution and upload it to PyPI . Deploy Docs , which will tear down and rebuild the GitHub page where the doc site is hosted.","title":"Deploy process"},{"location":"dev_release/#when-are-releases-done","text":"It depends on the changes that are currently on the master branch but have not deployed yet. Generally speaking: Serious bugs are usually released immediately after they are fixed. New features can usually wait and are released on a weekly basis. Trivial changes are usually bundled with other changes and can wait indefinitely.","title":"When are releases done?"},{"location":"dev_test/","text":"Testing PyPDFForm uses pytest for testing and coverage.py for test coverages. Tests can be run by simply executing: coverage run -m pytest && coverage report --fail-under=100 Generate coverage report To generate a coverage report, run: coverage run -m pytest && coverage html And the coverage report can be viewed by opening htmlcov/index.html in a browser. Test breakdown Each PyPDFForm test is different. However, there is a general paradigm that almost all tests follow. In most cases, a test can be verbally summed up into three steps: Define an expected PDF file that the outcome of the test should look like. Execute a sequence of code using PyPDFForm to generate a PDF that should look like the expected PDF file. Compare the PDF generated by the test with the expected PDF file. Consider this example test: def test_fill(pdf_samples, request): expected_path = os.path.join(pdf_samples, \"sample_filled.pdf\") with open(expected_path, \"rb+\") as f: obj = PdfWrapper( os.path.join(pdf_samples, \"sample_template.pdf\") ).fill( { \"test\": \"test_1\", \"check\": True, \"test_2\": \"test_2\", \"check_2\": False, \"test_3\": \"test_3\", \"check_3\": True, }, ) request.config.results[\"expected_path\"] = expected_path request.config.results[\"stream\"] = obj.read() expected = f.read() assert len(obj.read()) == len(expected) assert obj.read() == expected The test starts by defining an expected PDF sample_filled.pdf : expected_path = os.path.join(pdf_samples, \"sample_filled.pdf\") The test then fills sample_template.pdf with a data dictionary using PdfWrapper : obj = PdfWrapper( os.path.join(pdf_samples, \"sample_template.pdf\") ).fill( { \"test\": \"test_1\", \"check\": True, \"test_2\": \"test_2\", \"check_2\": False, \"test_3\": \"test_3\", \"check_3\": True, }, ) These two lines should almost always be included in every test to make updating old tests easier: request.config.results[\"expected_path\"] = expected_path request.config.results[\"stream\"] = obj.read() Finally, the test compares the resulted stream from the test with the expected file stream: expected = f.read() assert len(obj.read()) == len(expected) assert obj.read() == expected","title":"Testing"},{"location":"dev_test/#testing","text":"PyPDFForm uses pytest for testing and coverage.py for test coverages. Tests can be run by simply executing: coverage run -m pytest && coverage report --fail-under=100","title":"Testing"},{"location":"dev_test/#generate-coverage-report","text":"To generate a coverage report, run: coverage run -m pytest && coverage html And the coverage report can be viewed by opening htmlcov/index.html in a browser.","title":"Generate coverage report"},{"location":"dev_test/#test-breakdown","text":"Each PyPDFForm test is different. However, there is a general paradigm that almost all tests follow. In most cases, a test can be verbally summed up into three steps: Define an expected PDF file that the outcome of the test should look like. Execute a sequence of code using PyPDFForm to generate a PDF that should look like the expected PDF file. Compare the PDF generated by the test with the expected PDF file. Consider this example test: def test_fill(pdf_samples, request): expected_path = os.path.join(pdf_samples, \"sample_filled.pdf\") with open(expected_path, \"rb+\") as f: obj = PdfWrapper( os.path.join(pdf_samples, \"sample_template.pdf\") ).fill( { \"test\": \"test_1\", \"check\": True, \"test_2\": \"test_2\", \"check_2\": False, \"test_3\": \"test_3\", \"check_3\": True, }, ) request.config.results[\"expected_path\"] = expected_path request.config.results[\"stream\"] = obj.read() expected = f.read() assert len(obj.read()) == len(expected) assert obj.read() == expected The test starts by defining an expected PDF sample_filled.pdf : expected_path = os.path.join(pdf_samples, \"sample_filled.pdf\") The test then fills sample_template.pdf with a data dictionary using PdfWrapper : obj = PdfWrapper( os.path.join(pdf_samples, \"sample_template.pdf\") ).fill( { \"test\": \"test_1\", \"check\": True, \"test_2\": \"test_2\", \"check_2\": False, \"test_3\": \"test_3\", \"check_3\": True, }, ) These two lines should almost always be included in every test to make updating old tests easier: request.config.results[\"expected_path\"] = expected_path request.config.results[\"stream\"] = obj.read() Finally, the test compares the resulted stream from the test with the expected file stream: expected = f.read() assert len(obj.read()) == len(expected) assert obj.read() == expected","title":"Test breakdown"},{"location":"draw/","text":"Draw stuffs PyPDFForm allows you to draw certain elements on a PDF. The purpose is in case there is a missing widget on your PDF form, and you need to put certain texts on it, or if you need to draw images. This section of the documentation will use this PDF as an example. This section of the documentation requires a basic understanding of the PDF coordinate system . All optional parameters will have a comment # optional after each of them. NOTE: Due to a known bug in a dependency, it is advised that these draw methods are called after a PDF form is filled. Otherwise, part (most noticeably radio buttons) or even all widgets of the PDF form might get removed after drawing things on it. Draw text from PyPDFForm import PdfWrapper pdf = PdfWrapper(\"sample_template.pdf\").draw_text( text=\"random text\", page_number=1, x=300, y=225, font=\"your_registered_font\", # optional font_size=12, # optional font_color=(1, 0, 0) # optional ) with open(\"output.pdf\", \"wb+\") as output: output.write(pdf.read()) Draw image from PyPDFForm import PdfWrapper pdf = PdfWrapper(\"sample_template.pdf\").draw_image( image=\"sample_image.jpg\", page_number=1, x=100, y=100, width=400, height=225, rotation=0 # optional ) with open(\"output.pdf\", \"wb+\") as output: output.write(pdf.read())","title":"Draw stuffs"},{"location":"draw/#draw-stuffs","text":"PyPDFForm allows you to draw certain elements on a PDF. The purpose is in case there is a missing widget on your PDF form, and you need to put certain texts on it, or if you need to draw images. This section of the documentation will use this PDF as an example. This section of the documentation requires a basic understanding of the PDF coordinate system . All optional parameters will have a comment # optional after each of them. NOTE: Due to a known bug in a dependency, it is advised that these draw methods are called after a PDF form is filled. Otherwise, part (most noticeably radio buttons) or even all widgets of the PDF form might get removed after drawing things on it.","title":"Draw stuffs"},{"location":"draw/#draw-text","text":"from PyPDFForm import PdfWrapper pdf = PdfWrapper(\"sample_template.pdf\").draw_text( text=\"random text\", page_number=1, x=300, y=225, font=\"your_registered_font\", # optional font_size=12, # optional font_color=(1, 0, 0) # optional ) with open(\"output.pdf\", \"wb+\") as output: output.write(pdf.read())","title":"Draw text"},{"location":"draw/#draw-image","text":"from PyPDFForm import PdfWrapper pdf = PdfWrapper(\"sample_template.pdf\").draw_image( image=\"sample_image.jpg\", page_number=1, x=100, y=100, width=400, height=225, rotation=0 # optional ) with open(\"output.pdf\", \"wb+\") as output: output.write(pdf.read())","title":"Draw image"},{"location":"fill/","text":"Fill a PDF form PyPDFForm uses a single depth, non-nested dictionary to fill a PDF form. As a result of this process, the filled PDF form will be flattened and no longer editable. This is to prevent future encoding issues, especially when multiple PDF forms with overlaps on widget names are combined. Fill text field and checkbox widgets As seen when we inspected this PDF , a text field can be filled with a value of string , whereas a checkbox can be filled with a boolean value: from PyPDFForm import PdfWrapper filled = PdfWrapper(\"sample_template.pdf\").fill( { \"test\": \"test_1\", \"check\": True, \"test_2\": \"test_2\", \"check_2\": False, \"test_3\": \"test_3\", \"check_3\": True, }, ) with open(\"output.pdf\", \"wb+\") as output: output.write(filled.read()) Fill radio button widgets A radio button group on a PDF form is a collection of radio buttons that share the same name. A PDF form with radio button groups can be filled using integer values where the value indicates which radio button to select among each radio button group: from PyPDFForm import PdfWrapper filled = PdfWrapper(\"sample_template_with_radio_button.pdf\").fill( { \"radio_1\": 0, \"radio_2\": 1, \"radio_3\": 2, }, ) with open(\"output.pdf\", \"wb+\") as output: output.write(filled.read()) Fill dropdown widgets Similar to radio buttons, a dropdown choice can be selected by specifying an integer value of the choice. Consider this PDF : from PyPDFForm import PdfWrapper filled = PdfWrapper(\"sample_template_with_dropdown.pdf\").fill( { \"dropdown_1\": 1 }, ) with open(\"output.pdf\", \"wb+\") as output: output.write(filled.read()) Fill signature widgets A signature field widget allows you to sign a PDF form in a handwritten format. PyPDFForm lets you use a signature image to populate any signature field widget. Consider this PDF and this signature image : from PyPDFForm import PdfWrapper signed = PdfWrapper(\"sample_template_with_signature.pdf\").fill( { \"signature\": \"sample_signature.png\" }, ) with open(\"output.pdf\", \"wb+\") as output: output.write(signed.read()) NOTE: As described here , the value of the signature in your dictionary can be a file path shown above, but also an open file object and a file stream that's in bytes . Fill image widgets (beta) NOTE: This is a beta feature, meaning it still needs to be tested against more PDF forms and may not work for some of them. An image field widget can be filled similarly to a signature field, by providing a value of file path, file object, or file stream. Consider this PDF and this image : from PyPDFForm import PdfWrapper filled = PdfWrapper(\"sample_template_with_image_field.pdf\").fill( { \"image_1\": \"sample_image.jpg\" }, ) with open(\"output.pdf\", \"wb+\") as output: output.write(filled.read())","title":"Fill a PDF form"},{"location":"fill/#fill-a-pdf-form","text":"PyPDFForm uses a single depth, non-nested dictionary to fill a PDF form. As a result of this process, the filled PDF form will be flattened and no longer editable. This is to prevent future encoding issues, especially when multiple PDF forms with overlaps on widget names are combined.","title":"Fill a PDF form"},{"location":"fill/#fill-text-field-and-checkbox-widgets","text":"As seen when we inspected this PDF , a text field can be filled with a value of string , whereas a checkbox can be filled with a boolean value: from PyPDFForm import PdfWrapper filled = PdfWrapper(\"sample_template.pdf\").fill( { \"test\": \"test_1\", \"check\": True, \"test_2\": \"test_2\", \"check_2\": False, \"test_3\": \"test_3\", \"check_3\": True, }, ) with open(\"output.pdf\", \"wb+\") as output: output.write(filled.read())","title":"Fill text field and checkbox widgets"},{"location":"fill/#fill-radio-button-widgets","text":"A radio button group on a PDF form is a collection of radio buttons that share the same name. A PDF form with radio button groups can be filled using integer values where the value indicates which radio button to select among each radio button group: from PyPDFForm import PdfWrapper filled = PdfWrapper(\"sample_template_with_radio_button.pdf\").fill( { \"radio_1\": 0, \"radio_2\": 1, \"radio_3\": 2, }, ) with open(\"output.pdf\", \"wb+\") as output: output.write(filled.read())","title":"Fill radio button widgets"},{"location":"fill/#fill-dropdown-widgets","text":"Similar to radio buttons, a dropdown choice can be selected by specifying an integer value of the choice. Consider this PDF : from PyPDFForm import PdfWrapper filled = PdfWrapper(\"sample_template_with_dropdown.pdf\").fill( { \"dropdown_1\": 1 }, ) with open(\"output.pdf\", \"wb+\") as output: output.write(filled.read())","title":"Fill dropdown widgets"},{"location":"fill/#fill-signature-widgets","text":"A signature field widget allows you to sign a PDF form in a handwritten format. PyPDFForm lets you use a signature image to populate any signature field widget. Consider this PDF and this signature image : from PyPDFForm import PdfWrapper signed = PdfWrapper(\"sample_template_with_signature.pdf\").fill( { \"signature\": \"sample_signature.png\" }, ) with open(\"output.pdf\", \"wb+\") as output: output.write(signed.read()) NOTE: As described here , the value of the signature in your dictionary can be a file path shown above, but also an open file object and a file stream that's in bytes .","title":"Fill signature widgets"},{"location":"fill/#fill-image-widgets-beta","text":"NOTE: This is a beta feature, meaning it still needs to be tested against more PDF forms and may not work for some of them. An image field widget can be filled similarly to a signature field, by providing a value of file path, file object, or file stream. Consider this PDF and this image : from PyPDFForm import PdfWrapper filled = PdfWrapper(\"sample_template_with_image_field.pdf\").fill( { \"image_1\": \"sample_image.jpg\" }, ) with open(\"output.pdf\", \"wb+\") as output: output.write(filled.read())","title":"Fill image widgets (beta)"},{"location":"inspect/","text":"Inspect a PDF form After a PDF form is prepared, PyPDFForm can be used to inspect names of all its widgets so that the data that's needed to fill it can be determined. There are several different methods this can be done with and feel free to choose the way that fits your needs the most. This section of the documentation will use this PDF as an example. Generate a preview PDF The first method of inspecting a PDF form is to generate a preview document. Each PdfWrapper object contains an attribute .preview which is a file stream that can be written to any disk file or memory buffer. Consider the following snippet: from PyPDFForm import PdfWrapper preview_stream = PdfWrapper(\"sample_template.pdf\").preview with open(\"output.pdf\", \"wb+\") as output: output.write(preview_stream) The generated preview PDF will have the name of each widget labeled on top of it in red. Generate a JSON schema that describes a PDF form The dictionary that's used to fill a PDF form can be described using a JSON schema. For example: import json from PyPDFForm import PdfWrapper pdf_form_schema = PdfWrapper(\"sample_template.pdf\").schema print(json.dumps(pdf_form_schema, indent=4, sort_keys=True)) The above snippet will yield the following output: { \"properties\": { \"check\": { \"type\": \"boolean\" }, \"check_2\": { \"type\": \"boolean\" }, \"check_3\": { \"type\": \"boolean\" }, \"test\": { \"type\": \"string\" }, \"test_2\": { \"type\": \"string\" }, \"test_3\": { \"type\": \"string\" } }, \"type\": \"object\" } In this case sample_template.pdf has three text fields named test , test_2 , and test_3 because they all have a type of string . It also has three checkboxes check , check_2 , and check_3 due to their boolean type. The JSON schema generated by PyPDFForm can be used to validate against the data you use to fill a PDF form. Generate sample data Lastly, PyPDFForm can generate some sample data that can be directly used to fill a PDF form: from pprint import pprint from PyPDFForm import PdfWrapper pprint(PdfWrapper(\"sample_template.pdf\").sample_data) The above snippet will give you a sample dictionary: {'check': True, 'check_2': True, 'check_3': True, 'test': 'test', 'test_2': 'test_2', 'test_3': 'test_3'}","title":"Inspect a PDF form"},{"location":"inspect/#inspect-a-pdf-form","text":"After a PDF form is prepared, PyPDFForm can be used to inspect names of all its widgets so that the data that's needed to fill it can be determined. There are several different methods this can be done with and feel free to choose the way that fits your needs the most. This section of the documentation will use this PDF as an example.","title":"Inspect a PDF form"},{"location":"inspect/#generate-a-preview-pdf","text":"The first method of inspecting a PDF form is to generate a preview document. Each PdfWrapper object contains an attribute .preview which is a file stream that can be written to any disk file or memory buffer. Consider the following snippet: from PyPDFForm import PdfWrapper preview_stream = PdfWrapper(\"sample_template.pdf\").preview with open(\"output.pdf\", \"wb+\") as output: output.write(preview_stream) The generated preview PDF will have the name of each widget labeled on top of it in red.","title":"Generate a preview PDF"},{"location":"inspect/#generate-a-json-schema-that-describes-a-pdf-form","text":"The dictionary that's used to fill a PDF form can be described using a JSON schema. For example: import json from PyPDFForm import PdfWrapper pdf_form_schema = PdfWrapper(\"sample_template.pdf\").schema print(json.dumps(pdf_form_schema, indent=4, sort_keys=True)) The above snippet will yield the following output: { \"properties\": { \"check\": { \"type\": \"boolean\" }, \"check_2\": { \"type\": \"boolean\" }, \"check_3\": { \"type\": \"boolean\" }, \"test\": { \"type\": \"string\" }, \"test_2\": { \"type\": \"string\" }, \"test_3\": { \"type\": \"string\" } }, \"type\": \"object\" } In this case sample_template.pdf has three text fields named test , test_2 , and test_3 because they all have a type of string . It also has three checkboxes check , check_2 , and check_3 due to their boolean type. The JSON schema generated by PyPDFForm can be used to validate against the data you use to fill a PDF form.","title":"Generate a JSON schema that describes a PDF form"},{"location":"inspect/#generate-sample-data","text":"Lastly, PyPDFForm can generate some sample data that can be directly used to fill a PDF form: from pprint import pprint from PyPDFForm import PdfWrapper pprint(PdfWrapper(\"sample_template.pdf\").sample_data) The above snippet will give you a sample dictionary: {'check': True, 'check_2': True, 'check_3': True, 'test': 'test', 'test_2': 'test_2', 'test_3': 'test_3'}","title":"Generate sample data"},{"location":"install/","text":"Installation and setup PyPDFForm is hosted on PyPI and any tool that supports downloading from it can be used. The most common option is to use pip. Install using pip PyPDFForm requires Python 3.8+. It is advised that a virtual environment is always created beforehand. Then you can run the following command to install: pip install PyPDFForm To upgrade PyPDFForm as well as all its dependencies, run: pip install -U PyPDFForm Create a PDF wrapper There are two classes provided by the library that abstract a PDF form. The FormWrapper class allows you to fill a PDF form if you don't need any other API. More info about FormWrapper can be found here . The class that implements most of PyPDFForm's APIs is PdfWrapper . It takes various optional parameters to instantiate, with the most important one being the PDF form \"template\". For example, if you download this PDF , you will want to instantiate your object like this: from PyPDFForm import PdfWrapper pdf = PdfWrapper(\"sample_template.pdf\") PyPDFForm does implement an adapter for different ways Python interacts with files. So you can pass your PDF form to PdfWrapper in three different ways: a file path, an open file object, and a file stream that's in bytes . This means the following two snippets are equivalent to the above: from PyPDFForm import PdfWrapper with open(\"sample_template.pdf\", \"rb+\") as template: pdf = PdfWrapper(template) from PyPDFForm import PdfWrapper with open(\"sample_template.pdf\", \"rb+\") as template: pdf = PdfWrapper(template.read()) This adaptation is universal across all APIs of PyPDFForm. So in later sections of the documentation whenever you see a function parameter that's a file path you can safely switch them for a file object or file stream. Write to a file Lastly, PdfWrapper also implements itself similar to an open file object. So you can write the PDF it holds to another file: from PyPDFForm import PdfWrapper pdf = PdfWrapper(\"sample_template.pdf\") with open(\"output.pdf\", \"wb+\") as output: output.write(pdf.read()) And it doesn't have to be a disk file, it can be a memory buffer as well: from io import BytesIO from PyPDFForm import PdfWrapper pdf = PdfWrapper(\"sample_template.pdf\") with BytesIO() as output: output.write(pdf.read())","title":"Installation and setup"},{"location":"install/#installation-and-setup","text":"PyPDFForm is hosted on PyPI and any tool that supports downloading from it can be used. The most common option is to use pip.","title":"Installation and setup"},{"location":"install/#install-using-pip","text":"PyPDFForm requires Python 3.8+. It is advised that a virtual environment is always created beforehand. Then you can run the following command to install: pip install PyPDFForm To upgrade PyPDFForm as well as all its dependencies, run: pip install -U PyPDFForm","title":"Install using pip"},{"location":"install/#create-a-pdf-wrapper","text":"There are two classes provided by the library that abstract a PDF form. The FormWrapper class allows you to fill a PDF form if you don't need any other API. More info about FormWrapper can be found here . The class that implements most of PyPDFForm's APIs is PdfWrapper . It takes various optional parameters to instantiate, with the most important one being the PDF form \"template\". For example, if you download this PDF , you will want to instantiate your object like this: from PyPDFForm import PdfWrapper pdf = PdfWrapper(\"sample_template.pdf\") PyPDFForm does implement an adapter for different ways Python interacts with files. So you can pass your PDF form to PdfWrapper in three different ways: a file path, an open file object, and a file stream that's in bytes . This means the following two snippets are equivalent to the above: from PyPDFForm import PdfWrapper with open(\"sample_template.pdf\", \"rb+\") as template: pdf = PdfWrapper(template) from PyPDFForm import PdfWrapper with open(\"sample_template.pdf\", \"rb+\") as template: pdf = PdfWrapper(template.read()) This adaptation is universal across all APIs of PyPDFForm. So in later sections of the documentation whenever you see a function parameter that's a file path you can safely switch them for a file object or file stream.","title":"Create a PDF wrapper"},{"location":"install/#write-to-a-file","text":"Lastly, PdfWrapper also implements itself similar to an open file object. So you can write the PDF it holds to another file: from PyPDFForm import PdfWrapper pdf = PdfWrapper(\"sample_template.pdf\") with open(\"output.pdf\", \"wb+\") as output: output.write(pdf.read()) And it doesn't have to be a disk file, it can be a memory buffer as well: from io import BytesIO from PyPDFForm import PdfWrapper pdf = PdfWrapper(\"sample_template.pdf\") with BytesIO() as output: output.write(pdf.read())","title":"Write to a file"},{"location":"prepare/","text":"Prepare a PDF form The most common tool to create a PDF form is Adobe Acrobat. A tutorial can be found here . There are other free alternatives like DocFly that support similar functionalities. Given a PDF that's not a form yet, PyPDFForm also supports creating a subset of PDF form widgets on it through coding. This section of the documentation will use this PDF as an example. This section of the documentation requires a basic understanding of the PDF coordinate system . All optional parameters will have a comment # optional after each of them. NOTE: For some PDF prep tools, creating widgets on their PDF forms may result in their original widgets getting flattened (e.g., this PDF which was prepared using Sejda ). So it is advised that you fill them first before creating any widget using PyPDFForm. Create a text field widget A text field widget can be created by downloading the PDF and running the following snippet: from PyPDFForm import PdfWrapper new_form = PdfWrapper(\"dummy.pdf\").create_widget( widget_type=\"text\", name=\"new_text_field_widget\", page_number=1, x=57, y=700, width=120, # optional height=40, # optional max_length=5, # optional font=\"Courier\", # optional font_size=15, # optional font_color=(1, 0, 0), # optional bg_color=(0, 0, 1), # optional border_color=(1, 0, 0), # optional border_width=5 # optional ) with open(\"output.pdf\", \"wb+\") as output: output.write(new_form.read()) Create a checkbox widget A checkbox widget can be created using the same method with some changes to the parameters: from PyPDFForm import PdfWrapper new_form = PdfWrapper(\"dummy.pdf\").create_widget( widget_type=\"checkbox\", name=\"new_checkbox_widget\", page_number=1, x=57, y=700, size=30, # optional button_style=\"check\", # optional tick_color=(0, 1, 0), # optional bg_color=(0, 0, 1), # optional border_color=(1, 0, 0), # optional border_width=5 # optional ) with open(\"output.pdf\", \"wb+\") as output: output.write(new_form.read()) The button_style parameter currently supports three options: check , circle , and cross . Create a dropdown widget A dropdown widget shares a similar set of parameters as a text field, with the only significant difference being a list of options needs to be specified: from PyPDFForm import PdfWrapper new_form = PdfWrapper(\"dummy.pdf\").create_widget( widget_type=\"dropdown\", name=\"new_dropdown_widget\", page_number=1, x=57, y=700, options=[ \"foo\", \"bar\", \"foobar\", ], width=120, # optional height=40, # optional font=\"Courier\", # optional font_size=15, # optional font_color=(1, 0, 0), # optional bg_color=(0, 0, 1), # optional border_color=(1, 0, 0), # optional border_width=5 # optional ) with open(\"output.pdf\", \"wb+\") as output: output.write(new_form.read())","title":"Prepare a PDF form"},{"location":"prepare/#prepare-a-pdf-form","text":"The most common tool to create a PDF form is Adobe Acrobat. A tutorial can be found here . There are other free alternatives like DocFly that support similar functionalities. Given a PDF that's not a form yet, PyPDFForm also supports creating a subset of PDF form widgets on it through coding. This section of the documentation will use this PDF as an example. This section of the documentation requires a basic understanding of the PDF coordinate system . All optional parameters will have a comment # optional after each of them. NOTE: For some PDF prep tools, creating widgets on their PDF forms may result in their original widgets getting flattened (e.g., this PDF which was prepared using Sejda ). So it is advised that you fill them first before creating any widget using PyPDFForm.","title":"Prepare a PDF form"},{"location":"prepare/#create-a-text-field-widget","text":"A text field widget can be created by downloading the PDF and running the following snippet: from PyPDFForm import PdfWrapper new_form = PdfWrapper(\"dummy.pdf\").create_widget( widget_type=\"text\", name=\"new_text_field_widget\", page_number=1, x=57, y=700, width=120, # optional height=40, # optional max_length=5, # optional font=\"Courier\", # optional font_size=15, # optional font_color=(1, 0, 0), # optional bg_color=(0, 0, 1), # optional border_color=(1, 0, 0), # optional border_width=5 # optional ) with open(\"output.pdf\", \"wb+\") as output: output.write(new_form.read())","title":"Create a text field widget"},{"location":"prepare/#create-a-checkbox-widget","text":"A checkbox widget can be created using the same method with some changes to the parameters: from PyPDFForm import PdfWrapper new_form = PdfWrapper(\"dummy.pdf\").create_widget( widget_type=\"checkbox\", name=\"new_checkbox_widget\", page_number=1, x=57, y=700, size=30, # optional button_style=\"check\", # optional tick_color=(0, 1, 0), # optional bg_color=(0, 0, 1), # optional border_color=(1, 0, 0), # optional border_width=5 # optional ) with open(\"output.pdf\", \"wb+\") as output: output.write(new_form.read()) The button_style parameter currently supports three options: check , circle , and cross .","title":"Create a checkbox widget"},{"location":"prepare/#create-a-dropdown-widget","text":"A dropdown widget shares a similar set of parameters as a text field, with the only significant difference being a list of options needs to be specified: from PyPDFForm import PdfWrapper new_form = PdfWrapper(\"dummy.pdf\").create_widget( widget_type=\"dropdown\", name=\"new_dropdown_widget\", page_number=1, x=57, y=700, options=[ \"foo\", \"bar\", \"foobar\", ], width=120, # optional height=40, # optional font=\"Courier\", # optional font_size=15, # optional font_color=(1, 0, 0), # optional bg_color=(0, 0, 1), # optional border_color=(1, 0, 0), # optional border_width=5 # optional ) with open(\"output.pdf\", \"wb+\") as output: output.write(new_form.read())","title":"Create a dropdown widget"},{"location":"simple_fill/","text":"Fill a PDF form in place The FormWrapper class allows you to fill a PDF form in place as if you were filling it manually. Normal mode Similar to the PdfWrapper class, the FormWrapper also supports widgets including text fields, checkboxes, radio buttons, dropdowns, and paragraphs. However, it does NOT support signature or image widgets. Consider this PDF : from PyPDFForm import FormWrapper filled = FormWrapper(\"sample_template_with_dropdown.pdf\").fill( { \"test_1\": \"test_1\", \"test_2\": \"test_2\", \"test_3\": \"test_3\", \"check_1\": True, \"check_2\": True, \"check_3\": True, \"radio_1\": 1, \"dropdown_1\": 1, }, flatten=False, # optional ) with open(\"output.pdf\", \"wb+\") as output: output.write(filled.read()) The optional parameter flatten has a default value of False , meaning PDF forms filled using FormWrapper will by default remain editable. Setting it to True will flatten the PDF after it's filled, making all widgets read only. Adobe mode (beta) NOTE: This is a beta feature, meaning it still needs to be tested against more PDF forms and may not work for some of them. Currently, there are some known issues with Adobe Acrobat displaying PDF forms filled using normal mode. Specifically the text content that gets filled into a text field widget will only appear when the text field is clicked and selected. This is not an issue in browsers like Chrome or other PDF viewing apps like Document Viewer (the default PDF app on Ubuntu). By setting the optional parameter adobe_mode (default value is False ) to True when invoking the fill method, FormWrapper will fill a PDF form such that its text fields will be displayed correctly when opened using Adobe Acrobat. Consider this PDF : from PyPDFForm import FormWrapper filled = FormWrapper(\"sample_template_with_dropdown.pdf\").fill( { \"test_1\": \"test_1\", \"test_2\": \"test_2\", \"test_3\": \"test_3\", \"check_1\": True, \"check_2\": True, \"check_3\": True, \"radio_1\": 1, \"dropdown_1\": 1, }, adobe_mode=True, # optional ) with open(\"output.pdf\", \"wb+\") as output: output.write(filled.read()) NOTE: However, enabling Adobe mode may result in some unexpected style changes for checkboxes and radio buttons. It may even result in selected radio button not displaying correctly when opened using Adobe Acrobat. It's currently unclear why such behaviors exist. If you have trouble with these behaviors, consider using PdfWrapper instead to fill your PDF forms.","title":"Fill a PDF form in place"},{"location":"simple_fill/#fill-a-pdf-form-in-place","text":"The FormWrapper class allows you to fill a PDF form in place as if you were filling it manually.","title":"Fill a PDF form in place"},{"location":"simple_fill/#normal-mode","text":"Similar to the PdfWrapper class, the FormWrapper also supports widgets including text fields, checkboxes, radio buttons, dropdowns, and paragraphs. However, it does NOT support signature or image widgets. Consider this PDF : from PyPDFForm import FormWrapper filled = FormWrapper(\"sample_template_with_dropdown.pdf\").fill( { \"test_1\": \"test_1\", \"test_2\": \"test_2\", \"test_3\": \"test_3\", \"check_1\": True, \"check_2\": True, \"check_3\": True, \"radio_1\": 1, \"dropdown_1\": 1, }, flatten=False, # optional ) with open(\"output.pdf\", \"wb+\") as output: output.write(filled.read()) The optional parameter flatten has a default value of False , meaning PDF forms filled using FormWrapper will by default remain editable. Setting it to True will flatten the PDF after it's filled, making all widgets read only.","title":"Normal mode"},{"location":"simple_fill/#adobe-mode-beta","text":"NOTE: This is a beta feature, meaning it still needs to be tested against more PDF forms and may not work for some of them. Currently, there are some known issues with Adobe Acrobat displaying PDF forms filled using normal mode. Specifically the text content that gets filled into a text field widget will only appear when the text field is clicked and selected. This is not an issue in browsers like Chrome or other PDF viewing apps like Document Viewer (the default PDF app on Ubuntu). By setting the optional parameter adobe_mode (default value is False ) to True when invoking the fill method, FormWrapper will fill a PDF form such that its text fields will be displayed correctly when opened using Adobe Acrobat. Consider this PDF : from PyPDFForm import FormWrapper filled = FormWrapper(\"sample_template_with_dropdown.pdf\").fill( { \"test_1\": \"test_1\", \"test_2\": \"test_2\", \"test_3\": \"test_3\", \"check_1\": True, \"check_2\": True, \"check_3\": True, \"radio_1\": 1, \"dropdown_1\": 1, }, adobe_mode=True, # optional ) with open(\"output.pdf\", \"wb+\") as output: output.write(filled.read()) NOTE: However, enabling Adobe mode may result in some unexpected style changes for checkboxes and radio buttons. It may even result in selected radio button not displaying correctly when opened using Adobe Acrobat. It's currently unclear why such behaviors exist. If you have trouble with these behaviors, consider using PdfWrapper instead to fill your PDF forms.","title":"Adobe mode (beta)"},{"location":"style/","text":"Change text field styles PyPDFForm gives you the ability to modify certain styles of text fields through code. This allows you to manipulate appearances of the texts without having to make changes to your PDF form template. All these style changes can be done both globally upon instantiating a PdfWrapper object and individually for each text field widget. This section of the documentation will use this PDF as an example. Change font Some fonts, for example Courier and Helvetica , are builtin as part of the PDF standards. These fonts can be set without registration: from PyPDFForm import PdfWrapper form = PdfWrapper(\"sample_template.pdf\", global_font=\"Courier\") form.widgets[\"test\"].font = \"Helvetica\" form.fill( { \"test\": \"test_1\", \"check\": True, \"test_2\": \"test_2\", \"check_2\": False, \"test_3\": \"test_3\", \"check_3\": True, }, ) with open(\"output.pdf\", \"wb+\") as output: output.write(form.read()) Other non-standard fonts, for example Liberation Serif , will need a TrueType file to be registered before they can be set: from PyPDFForm import PdfWrapper PdfWrapper.register_font(\"new_font_name\", \"LiberationSerif-Regular.ttf\") form = PdfWrapper(\"sample_template.pdf\", global_font=\"new_font_name\") form.widgets[\"test\"].font = \"new_font_name\" form.fill( { \"test\": \"test_1\", \"check\": True, \"test_2\": \"test_2\", \"check_2\": False, \"test_3\": \"test_3\", \"check_3\": True, }, ) with open(\"output.pdf\", \"wb+\") as output: output.write(form.read()) Change font size PyPDFForm allows setting font size using a numerical float value: from PyPDFForm import PdfWrapper form = PdfWrapper(\"sample_template.pdf\", global_font_size=20) form.widgets[\"test\"].font_size = 30.5 form.fill( { \"test\": \"test_1\", \"check\": True, \"test_2\": \"test_2\", \"check_2\": False, \"test_3\": \"test_3\", \"check_3\": True, }, ) with open(\"output.pdf\", \"wb+\") as output: output.write(form.read()) Change font color PyPDFForm allows setting font color using an RGB numerical tuple : from PyPDFForm import PdfWrapper form = PdfWrapper(\"sample_template.pdf\", global_font_color=(1, 0, 0)) form.widgets[\"test\"].font_color = (0.2, 0, 0.5) form.fill( { \"test\": \"test_1\", \"check\": True, \"test_2\": \"test_2\", \"check_2\": False, \"test_3\": \"test_3\", \"check_3\": True, }, ) with open(\"output.pdf\", \"wb+\") as output: output.write(form.read())","title":"Change text field styles"},{"location":"style/#change-text-field-styles","text":"PyPDFForm gives you the ability to modify certain styles of text fields through code. This allows you to manipulate appearances of the texts without having to make changes to your PDF form template. All these style changes can be done both globally upon instantiating a PdfWrapper object and individually for each text field widget. This section of the documentation will use this PDF as an example.","title":"Change text field styles"},{"location":"style/#change-font","text":"Some fonts, for example Courier and Helvetica , are builtin as part of the PDF standards. These fonts can be set without registration: from PyPDFForm import PdfWrapper form = PdfWrapper(\"sample_template.pdf\", global_font=\"Courier\") form.widgets[\"test\"].font = \"Helvetica\" form.fill( { \"test\": \"test_1\", \"check\": True, \"test_2\": \"test_2\", \"check_2\": False, \"test_3\": \"test_3\", \"check_3\": True, }, ) with open(\"output.pdf\", \"wb+\") as output: output.write(form.read()) Other non-standard fonts, for example Liberation Serif , will need a TrueType file to be registered before they can be set: from PyPDFForm import PdfWrapper PdfWrapper.register_font(\"new_font_name\", \"LiberationSerif-Regular.ttf\") form = PdfWrapper(\"sample_template.pdf\", global_font=\"new_font_name\") form.widgets[\"test\"].font = \"new_font_name\" form.fill( { \"test\": \"test_1\", \"check\": True, \"test_2\": \"test_2\", \"check_2\": False, \"test_3\": \"test_3\", \"check_3\": True, }, ) with open(\"output.pdf\", \"wb+\") as output: output.write(form.read())","title":"Change font"},{"location":"style/#change-font-size","text":"PyPDFForm allows setting font size using a numerical float value: from PyPDFForm import PdfWrapper form = PdfWrapper(\"sample_template.pdf\", global_font_size=20) form.widgets[\"test\"].font_size = 30.5 form.fill( { \"test\": \"test_1\", \"check\": True, \"test_2\": \"test_2\", \"check_2\": False, \"test_3\": \"test_3\", \"check_3\": True, }, ) with open(\"output.pdf\", \"wb+\") as output: output.write(form.read())","title":"Change font size"},{"location":"style/#change-font-color","text":"PyPDFForm allows setting font color using an RGB numerical tuple : from PyPDFForm import PdfWrapper form = PdfWrapper(\"sample_template.pdf\", global_font_color=(1, 0, 0)) form.widgets[\"test\"].font_color = (0.2, 0, 0.5) form.fill( { \"test\": \"test_1\", \"check\": True, \"test_2\": \"test_2\", \"check_2\": False, \"test_3\": \"test_3\", \"check_3\": True, }, ) with open(\"output.pdf\", \"wb+\") as output: output.write(form.read())","title":"Change font color"},{"location":"utils/","text":"Other utilities There are some additional utilities PyPDFForm provides similar to many other PDF libraries. This section of the documentation will use this PDF as an example. Extract pages Each PdfWrapper object has an attribute .pages . It's a list of PdfWrapper objects where each one of them is a single page: from PyPDFForm import PdfWrapper first_page = PdfWrapper(\"sample_template.pdf\").pages[0] first_page.fill( { \"test\": \"test_1\", \"check\": True, }, ) with open(\"output.pdf\", \"wb+\") as output: output.write(first_page.read()) Merge multiple PDFs More than one PDF files can be merged by simply adding their PdfWrapper objects. Consider this PDF : from PyPDFForm import PdfWrapper pdf_one = PdfWrapper(\"dummy.pdf\") pdf_two = PdfWrapper(\"sample_template.pdf\") merged = pdf_one + pdf_two with open(\"output.pdf\", \"wb+\") as output: output.write(merged.read()) Or if you wish to re-organize your pages: from PyPDFForm import PdfWrapper pdf_one = PdfWrapper(\"dummy.pdf\") pdf_two = PdfWrapper(\"sample_template.pdf\") merged = pdf_two.pages[0] + pdf_one + pdf_two.pages[1] + pdf_two.pages[2] with open(\"output.pdf\", \"wb+\") as output: output.write(merged.read()) Change PDF version PyPDFForm supports modifying PDF version up to 2.0: from PyPDFForm import PdfWrapper new_version = PdfWrapper(\"sample_template.pdf\").change_version(\"2.0\") with open(\"output.pdf\", \"wb+\") as output: output.write(new_version.read())","title":"Other utilities"},{"location":"utils/#other-utilities","text":"There are some additional utilities PyPDFForm provides similar to many other PDF libraries. This section of the documentation will use this PDF as an example.","title":"Other utilities"},{"location":"utils/#extract-pages","text":"Each PdfWrapper object has an attribute .pages . It's a list of PdfWrapper objects where each one of them is a single page: from PyPDFForm import PdfWrapper first_page = PdfWrapper(\"sample_template.pdf\").pages[0] first_page.fill( { \"test\": \"test_1\", \"check\": True, }, ) with open(\"output.pdf\", \"wb+\") as output: output.write(first_page.read())","title":"Extract pages"},{"location":"utils/#merge-multiple-pdfs","text":"More than one PDF files can be merged by simply adding their PdfWrapper objects. Consider this PDF : from PyPDFForm import PdfWrapper pdf_one = PdfWrapper(\"dummy.pdf\") pdf_two = PdfWrapper(\"sample_template.pdf\") merged = pdf_one + pdf_two with open(\"output.pdf\", \"wb+\") as output: output.write(merged.read()) Or if you wish to re-organize your pages: from PyPDFForm import PdfWrapper pdf_one = PdfWrapper(\"dummy.pdf\") pdf_two = PdfWrapper(\"sample_template.pdf\") merged = pdf_two.pages[0] + pdf_one + pdf_two.pages[1] + pdf_two.pages[2] with open(\"output.pdf\", \"wb+\") as output: output.write(merged.read())","title":"Merge multiple PDFs"},{"location":"utils/#change-pdf-version","text":"PyPDFForm supports modifying PDF version up to 2.0: from PyPDFForm import PdfWrapper new_version = PdfWrapper(\"sample_template.pdf\").change_version(\"2.0\") with open(\"output.pdf\", \"wb+\") as output: output.write(new_version.read())","title":"Change PDF version"}]}